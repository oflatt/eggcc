(ruleset interval-analysis)
(ruleset interval-rewrite)

(datatype Bound
  (IntB i64)
  (BoolB bool)
  (Dead) ;; a bound on dead code, so any value can be chosen
  (bound-max Bound Bound)
  (bound-min Bound Bound))

; bound tables
(function lo-bound (Expr) Bound :unextractable :merge (bound-max old new))
(function hi-bound (Expr) Bound :unextractable :merge (bound-min old new))

; if lo > hi, we have proven that this code is dead (as long as all our rules are sound)
; In this case, interval analysis might start going crazy and fail to saturate
; So we immediately set the bounds to (Dead)

; combinators
(rewrite (bound-max (IntB x) (IntB y))
         (IntB (max x y))
         :ruleset interval-analysis)
(rewrite (bound-min (IntB x) (IntB y))
         (IntB (min x y))
         :ruleset interval-analysis)
(rewrite (bound-max (BoolB x) (BoolB y))
         (BoolB (or x y))
         :ruleset interval-analysis)
(rewrite (bound-min (BoolB x) (BoolB y))
         (BoolB (and x y))
         :ruleset interval-analysis)


; =================================
; Constants
; =================================
(rule ((= lhs (Const (Int x) ty ctx)))
      (
        (set (lo-bound lhs) (IntB x))
        (set (hi-bound lhs) (IntB x))
      )
      :ruleset interval-analysis)

(rule ((= lhs (Const (Bool x) ty ctx)))
      (
        (set (lo-bound lhs) (BoolB x))
        (set (hi-bound lhs) (BoolB x))
      )
      :ruleset interval-analysis)

; =================================
; Constant Folding
; =================================
(rule (
       (= (IntB x) (lo-bound expr))
       (= (IntB x) (hi-bound expr))
       (HasArgType expr ty)
       (ContextOf expr ctx)
      )
      ((union expr (Const (Int x) ty ctx)))
      :ruleset interval-analysis)

(rule (
       (= (BoolB x) (lo-bound expr))
       (= (BoolB x) (hi-bound expr))
       (HasArgType expr ty)
       (ContextOf expr ctx)
      )
      ((union expr (Const (Bool x) ty ctx)))
      :ruleset interval-analysis)

; lower bound being true means the bool must be true
(rule (
       (= (BoolB true) (lo-bound expr))
       (HasArgType expr ty)
       (ContextOf expr ctx)
      )
      ((union expr (Const (Bool true) ty ctx)))
      :ruleset interval-analysis)

; upper bound being false means the bool must be false
(rule (
       (= (BoolB false) (hi-bound expr))
       (HasArgType expr ty)
       (ContextOf expr ctx)
      )
      ((union expr (Const (Bool false) ty ctx)))
      :ruleset interval-analysis)

; Same rules, but for Ifs that have multiple outputs
(rule (
        (= lhs (If pred inputs thn els))
        (= lo-thn (lo-bound (Get thn i)))
        (= lo-els (lo-bound (Get els i)))
      )
      ((set (lo-bound (Get lhs i)) (bound-min lo-thn lo-els)))
      :ruleset interval-analysis)
(rule (
       (= lhs (If cond inputs thn els))
       (= hi-thn (hi-bound (Get thn i)))
       (= hi-els (hi-bound (Get els i)))
      )
      ((set (hi-bound (Get lhs i)) (bound-max hi-thn hi-els)))
      :ruleset interval-analysis)


;; Push intervals for inputs into if region
(rule (
       (= if (If pred inputs then_ else_))
       (= ctx (Arg ty (InIf b pred inputs)))
       (HasType inputs ty)
       (= lo (lo-bound (Get inputs i)))

      )
      ((set (lo-bound (Get ctx i)) lo))
      :ruleset interval-analysis)
(rule (
       (= if (If pred inputs then_ else_))
       (= ctx (Arg ty (InIf b pred inputs)))
       (HasType inputs ty)
       (= hi (hi-bound (Get inputs i)))

      )
      ((set (hi-bound (Get ctx i)) hi))
      :ruleset interval-analysis)




(rule (
       ;; argument has loop context
       (Arg ty (InLoop inputs outputs))
       (DoWhile inputs outputs)
       ;; in the loop, the argument is passed through
       ;; note that some_ctx is not the same as (InLoop inputs outputs)
       (= (Get (Arg ty (InLoop inputs outputs)) ith) (Get outputs (+ 1 ith)))
       ;; input has some bound
       (= bound (lo-bound (Get inputs ith)))
      )
      (
       (set (lo-bound (Get (Arg ty (InLoop inputs outputs)) ith)) bound)
      )
      :ruleset interval-analysis)
(rule (
       ;; argument has loop context
       (Arg ty (InLoop inputs outputs))
       (DoWhile inputs outputs)
       ;; in the loop, the argument is passed through
       (= (Get (Arg ty (InLoop inputs outputs)) ith) (Get outputs (+ 1 ith)))
       ;; input has some bound
       (= bound (hi-bound (Get inputs ith)))
      )
      (
       (set (hi-bound (Get (Arg ty (InLoop inputs outputs)) ith)) bound)
      )
      :ruleset interval-analysis)

