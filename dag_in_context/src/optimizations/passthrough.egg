(ruleset passthrough)


;; Pass through thetas
(rule ((= lhs (Get loop i))
        (= loop (DoWhile inputs pred-outputs))
        (= (Get pred-outputs (+ i 1)) (Get (Arg _ty _ctx) i))
        ;; only pass through pure types, since some loops don't terminate
        ;; so the state edge must pass through them
        (HasType lhs lhs_ty)
        (PureType lhs_ty)
        )
       ((union lhs (Get inputs i)))
       :ruleset passthrough)


;; Pass through if arguments
(rule ((= if (If pred inputs then_ else_))
       (= then-branch (Get then_ i))
       (= else-branch (Get else_ i))
       (= then-branch (Get (Arg arg_ty _then_ctx) j))
       (= else-branch (Get (Arg arg_ty _else_ctx) j))
       (HasType then-branch lhs_ty)
       (!= lhs_ty (Base (StateT))))
      ((union (Get if i) (Get inputs j)))
      :ruleset passthrough)


(ruleset sanitycheck)

(rule ((DoWhile inputs outputs)
       (= (Get outputs (+ ith 1)) (Get (Arg ty ctx) ith))
       (= ctx (InLoop inputs2 outputs2))
       (!= inputs2 inputs))
      ((DebugExpr inputs2)
       (DebugExpr inputs)
       (panic "found")
       )
       :ruleset sanitycheck)

(rule ((= (InLoop inputs1 outputs1) (InLoop inputs2 outputs2))
       (!= inputs1 inputs2))
      ((panic "found unioned ctxs"))
       :ruleset sanitycheck)