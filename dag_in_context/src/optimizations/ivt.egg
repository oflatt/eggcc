(relation IVTNewInputsAnalysisDemand (Expr))

(ruleset ivt-analysis)

(sort IVTRes)
;;                              perm passthrough-perm passthrough-type passthrough-type-len
(function IVTAnalysisRes (Expr Expr             TypeList         i64) IVTRes)
(function IVTMin (IVTRes IVTRes) IVTRes)

(rule ((= lhs (IVTMin (IVTAnalysisRes _a _b _c len1) (IVTAnalysisRes _d _e _f len2)))
       (<= len1 len2))
      ((union lhs (IVTAnalysisRes _a _b _c len1)))
        :ruleset ivt-analysis)
(rule ((= lhs (IVTMin (IVTAnalysisRes _a _b _c len1) (IVTAnalysisRes _d _e _f len2)))
       (> len1 len2))
      ((union lhs (IVTAnalysisRes _d _e _f len2)))
        :ruleset ivt-analysis)

;; use an analysis to avoid exploring all combinations of passthrough vs not passed through values. Always prefer not passed through
;;                                  expr1 curr  expr2  result
(function IVTNewInputsAnalysisImpl (Expr  Expr  Expr) IVTRes :merge (IVTMin old new))

;; IVTNewInputsAnalysis computes a permutation perm which corresponds to accessing elements of an if region.
;; It also makes accesses of passthrough arguments access new indices after the length of the if region.
;; For example, if expr1 is: [get(if, 1), get(arg, 1), get(if, 0), get(arg, 3)]
;; It produces a new permutation: [get(arg, 1), get(arg, 2), get(arg, 0), get(arg, 3)]
;; The accesses of the if statement remain unchanged, and the accesses of the passthrough arguments are moved to the end.
;; This new permutation is intended to be used with a substitution argument (Concat if-statement passthrough-args)
;; Also produced is a passthrough-perm, which selects all of the passthrough arguments and puts them in a single tuple
;;                              expr1 expr2 result
(function IVTNewInputsAnalysis (Expr  Expr) IVTRes :merge (IVTMin old new))


(rule (
    (DoWhile inpW outW)
) (
    (IVTNewInputsAnalysisDemand outW)
) :ruleset ivt-analysis)

(rule (
    (IVTNewInputsAnalysisDemand loop-body)
    ;; first input is a predicate
    (= loop-body (Concat (Single pred) rest))
    ;; another input is an if statement with shared predicate
    (= (Get loop-body i) (Get (If pred inputs thn else) j))
    (!= i 0)
) (
    (let perm (Empty (TmpType) (NoCtx)))
    (set
     (IVTNewInputsAnalysisImpl loop-body rest (If pred inputs thn else))
     (IVTAnalysisRes perm perm (TNil) 0))
) :ruleset ivt-analysis)

;; recursive case for accessing the if statement
(rule (
    (= (IVTNewInputsAnalysisImpl loop-body curr expr) (IVTAnalysisRes perm pperm passthrough-tys len))
    (= curr (Concat (Single (Get expr ith)) rest))
) (
    (let new-perm (Concat perm (Single (Get (Arg (TmpType) (NoCtx)) ith))))
    (set (IVTNewInputsAnalysisImpl loop-body rest expr)
         (IVTAnalysisRes new-perm  pperm passthrough-tys len))
) :ruleset ivt-analysis)

;; recursive case for accessing a passed-through argument
(rule (
    (= (IVTNewInputsAnalysisImpl loop-body curr expr)
       (IVTAnalysisRes perm pperm passthrough-tys len))
    (= curr (Concat (Single next) rest))
    (= next (Get (Arg ty ctx) ith))
    (= next (Get loop-body (+ ith 1)))
    (HasType (Get (Arg ty ctx) ith) (Base new-ty))
    (= expr (If pred inputs then else))
    (= (tuple-length expr) if-len)
) (
    (let get-passed-through (Single (Get (Arg (TmpType) (NoCtx)) (+ if-len len))))
    (let new-perm (Concat perm get-passed-through))
    (let original-get-index (Single (Get (Arg (TmpType) (NoCtx)) ith)))
    (let new-pperm (Concat pperm original-get-index))
    (let new-passthrough-tys (TLConcat passthrough-tys (TCons new-ty (TNil))))
    (set (IVTNewInputsAnalysisImpl loop-body rest expr)
         (IVTAnalysisRes new-perm new-pperm new-passthrough-tys (+ len 1)))
) :ruleset ivt-analysis)

; base case for accessing if statement
(rule (
    (= (IVTNewInputsAnalysisImpl loop-body (Single last) expr) (IVTAnalysisRes perm pperm passthrough-tys len))
    (= last (Get expr ith))
) (
    (let new-perm (Concat perm (Single (Get (Arg (TmpType) (NoCtx)) ith))))
    (set (IVTNewInputsAnalysis loop-body expr) (IVTAnalysisRes new-perm pperm passthrough-tys len))
) :ruleset ivt-analysis)

; base case for accessing a passed-through argument
(rule (
    (= (IVTNewInputsAnalysisImpl loop-body curr expr) (IVTAnalysisRes perm pperm passthrough-tys len))
    (= curr (Single (Get (Arg ty ctx) ith)))
    (= (Get loop-body (+ ith 1)) (Get curr 0))
    (HasType (Get (Arg ty ctx) ith) (Base new-ty))
    (= expr (If pred inputs then else))
    (= (tuple-length expr) if-len)
) (
    (let get-passed-through (Single (Get (Arg (TmpType) (NoCtx)) (+ if-len len))))
    (let new-perm (Concat perm get-passed-through))
    (let original-get-index (Single (Get (Arg (TmpType) (NoCtx)) ith)))
    (let new-pperm (Concat pperm original-get-index))
    (let new-passthrough-tys (TLConcat passthrough-tys (TCons new-ty (TNil))))
    (set (IVTNewInputsAnalysis loop-body expr) (IVTAnalysisRes new-perm new-pperm new-passthrough-tys (+ len 1)))
) :ruleset ivt-analysis)


(ruleset loop-inversion)

